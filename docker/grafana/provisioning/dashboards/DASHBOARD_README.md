# Grafana ダッシュボード完全ガイド

## 📊 概要

このディレクトリには、Camel + Kafka + SpringBoot分散アプリケーションの包括的な監視ダッシュボードが含まれています。

---

## 🎯 提供ダッシュボード

### 1. **camel-comprehensive-dashboard.json** ⭐️ メインダッシュボード

**用途:** 日常運用、パフォーマンス監視、トラブルシューティング

**含まれるセクション:** 7セクション、23パネル

| セクション | パネル数 | 目的 |
|-----------|---------|------|
| 📊 システム概要 | 4 | 稼働時間、CPU、メモリ、スレッド |
| 🐫 Camel ルート | 5 | メッセージ処理、エラー率、処理時間 |
| 🌐 HTTP エンドポイント | 3 | リクエストレート、レスポンスタイム、ステータスコード |
| 🧠 JVM メモリ | 4 | ヒープ、GC、メモリ割り当て |
| 🚀 Undertow Webサーバー | 5 | キューサイズ、スレッド状態、接続数 |
| 📨 Kafka メッセージング | 3 | Consumer Lag、メッセージレート、レイテンシ |
| 📊 メッセージフロー | 1 | エンドツーエンドのフロー可視化 |

---

## 📖 各セクション詳細

### 1. 📊 システム概要

システム全体の健全性を一目で確認。

#### ⏱️ アプリケーション稼働時間
- **メトリクス:** `process_uptime_seconds`
- **単位:** 秒
- **目的:** アプリケーションの連続稼働時間
- **正常値:** 増加し続ける（再起動がない）

#### 💻 CPU使用率
- **メトリクス:** `process_cpu_usage * 100`
- **単位:** パーセント (0-100%)
- **閾値:**
  - 🟢 緑: < 50% （正常）
  - 🟡 黄: 50-70% （注意）
  - 🟠 橙: 70-85% （警告）
  - 🔴 赤: ≥ 85% （危険）
- **対策:** スケールアップまたはスケールアウト

#### 🧠 ヒープメモリ使用率
- **メトリクス:** `(jvm_memory_used_bytes / jvm_memory_max_bytes) * 100`
- **単位:** パーセント (0-100%)
- **閾値:**
  - 🟢 緑: < 60% （正常）
  - 🟡 黄: 60-80% （注意）
  - 🟠 橙: 80-90% （警告）
  - 🔴 赤: ≥ 90% （危険、OOMの可能性）
- **対策:** ヒープサイズ増加、メモリリーク調査

#### 🧵 アクティブスレッド数
- **メトリクス:** `jvm_threads_live_threads`
- **単位:** スレッド数
- **閾値:**
  - 🟢 緑: < 50 （正常）
  - 🟡 黄: 50-80 （注意）
  - 🟠 橙: 80-100 （警告）
  - 🔴 赤: ≥ 100 （危険）
- **対策:** スレッドリーク調査、デッドロック確認

---

### 2. 🐫 Camel ルート パフォーマンス

Apache Camelルートの処理状況。

#### 📨 メッセージ処理レート
- **メトリクス:** 
  - `rate(camel_exchanges_total[1m])` - 総処理数
  - `rate(camel_exchanges_succeeded_total[1m])` - 成功数
  - `rate(camel_exchanges_failed_total[1m])` - 失敗数
- **単位:** ops (operations per second)
- **確認ポイント:**
  - Totalと Successがほぼ同じ → 正常
  - Failedが増加 → エラー調査が必要

#### ❌ エラー率
- **メトリクス:** `(failed / total) * 100`
- **単位:** パーセント
- **閾値:**
  - 🟢 緑: < 1% （優秀）
  - 🟡 黄: 1-5% （許容範囲）
  - 🟠 橙: 5-10% （要改善）
  - 🔴 赤: ≥ 10% （深刻）
- **対策:** ログ確認、トレース分析

#### ⏱️ 平均処理時間
- **メトリクス:** `camel_route_policy_seconds_sum / camel_route_policy_seconds_count`
- **単位:** 秒
- **正常値:** < 1秒（ルートによる）
- **対策:** ボトルネック特定、最適化

#### 📊 処理中メッセージ数（Inflight）
- **メトリクス:** `camel_exchanges_inflight`
- **単位:** メッセージ数
- **閾値:**
  - 🟢 緑: < 50 （正常）
  - 🟡 黄: 50-100 （注意）
  - 🟠 橙: 100-200 （警告）
  - 🔴 赤: ≥ 200 （キューイング発生）
- **対策:** スレッドプール調整、処理の最適化

#### 🚦 実行中ルート数
- **メトリクス:** `camel_routes_running_routes`
- **単位:** ルート数
- **確認ポイント:** 期待されるルート数と一致するか

---

### 3. 🌐 HTTP エンドポイント

Webエンドポイントのパフォーマンス。

#### 📡 HTTPリクエストレート
- **メトリクス:** `sum by (uri) (rate(http_server_requests_seconds_count[1m]))`
- **単位:** req/sec
- **確認ポイント:** エンドポイント別のリクエスト分布

#### ⏰ HTTPレスポンスタイム
- **メトリクス:**
  - 平均: `sum / count`
  - 最大: `http_server_requests_seconds_max`
- **単位:** 秒
- **目標値:**
  - 平均: < 0.5秒
  - 最大: < 2秒
- **対策:** 遅いエンドポイントの最適化

#### 🚨 HTTPステータスコード別レート
- **メトリクス:** `sum by (status) (rate(...))`
- **確認ポイント:**
  - 🟢 2xx: 成功レスポンス
  - 🟠 4xx: クライアントエラー
  - 🔴 5xx: サーバーエラー（要対応）

---

### 4. 🧠 JVM メモリ詳細

JVMメモリの詳細分析。

#### 💾 ヒープメモリ使用量推移
- **メトリクス:**
  - Used: `jvm_memory_used_bytes{area="heap"}`
  - Committed: `jvm_memory_committed_bytes{area="heap"}`
  - Max: `jvm_memory_max_bytes{area="heap"}`
- **単位:** バイト
- **確認ポイント:**
  - Used が Max に近づく → メモリ不足
  - Committed が増加 → JVMが追加メモリを確保

#### 🗑️ ガベージコレクション
- **メトリクス:**
  - 回数: `rate(jvm_gc_pause_seconds_count[1m]) * 60`
  - 平均時間: `sum / count`
- **単位:** 回数/分、秒
- **正常値:**
  - 回数: < 10回/分
  - 時間: < 0.1秒
- **対策:** GCチューニング、ヒープサイズ調整

#### 📦 メモリ割り当てレート
- **メトリクス:**
  - Allocated: `rate(jvm_gc_memory_allocated_bytes_total[1m])`
  - Promoted: `rate(jvm_gc_memory_promoted_bytes_total[1m])`
- **単位:** バイト/秒
- **確認ポイント:** Promotedが高い → Old世代へのメモリ移動が多い

#### ⚠️ GCオーバーヘッド率
- **メトリクス:** `jvm_gc_overhead_percent`
- **単位:** パーセント
- **閾値:**
  - 🟢 緑: < 5% （正常）
  - 🟡 黄: 5-10% （注意）
  - 🟠 橙: 10-20% （警告）
  - 🔴 赤: ≥ 20% （深刻）
- **対策:** メモリリーク調査、ヒープサイズ増加

---

### 5. 🚀 Undertow Webサーバー ⭐️ 重要

Undertow Webサーバーの詳細監視。

#### ⭐ リクエストキューサイズ
- **メトリクス:** `undertow_request_queue_size`
- **単位:** リクエスト数
- **閾値:**
  - 🟢 緑: 0 （理想）
  - 🟡 黄: 1-10 （軽微な遅延）
  - 🟠 橙: 10-50 （キューイング発生）
  - 🔴 赤: ≥ 50 （深刻なボトルネック）
- **意味:** 
  - 0 = すべてのリクエストが即座に処理されている
  - > 0 = ワーカースレッドが不足、リクエストが待機中
- **対策:** ワーカースレッド数増加、スケールアウト

#### 🧵 ワーカースレッド状態
- **メトリクス:**
  - Busy: `undertow_worker_threads_busy`
  - Idle: `undertow_worker_threads_idle`
- **単位:** スレッド数
- **確認ポイント:**
  - Busy が Idleに近い → スレッドプールがほぼ使用されている
  - Idle が多い → リソースに余裕がある

#### 🔌 アクティブ接続数
- **メトリクス:** `undertow_active_connections`
- **単位:** 接続数
- **閾値:**
  - 🟢 緑: < 100 （正常）
  - 🟡 黄: 100-200 （注意）
  - 🟠 橙: 200-300 （警告）
  - 🔴 赤: ≥ 300 （高負荷）
- **対策:** 接続プール調整、Keep-Alive設定見直し

#### 📊 スレッド使用率
- **メトリクス:** `(busy / (busy + idle)) * 100`
- **単位:** パーセント
- **閾値:**
  - 🟢 緑: < 60% （余裕あり）
  - 🟡 黄: 60-80% （適度な使用）
  - 🟠 橙: 80-90% （高使用率）
  - 🔴 赤: ≥ 90% （限界に近い）
- **対策:** スレッド数増加、レプリカ追加

#### 📈 総リクエスト処理数
- **メトリクス:** `undertow_requests_total`
- **単位:** リクエスト数
- **確認ポイント:** 起動後の累計処理リクエスト数

---

### 6. 📨 Kafka メッセージング

Kafkaメッセージングの健全性。

#### 📊 Kafka Consumer Lag
- **メトリクス:** `kafka_consumer_fetch_manager_records_lag_max`
- **単位:** メッセージ数
- **閾値:**
  - 🟢 緑: < 100 （正常）
  - 🟡 黄: 100-500 （注意）
  - 🟠 橙: 500-1000 （警告）
  - 🔴 赤: ≥ 1000 （深刻な遅延）
- **意味:** 未処理メッセージ数
- **対策:** Consumer並列度増加、処理の最適化

#### 📬 Kafka メッセージレート
- **メトリクス:**
  - Producer: `rate(kafka_producer_metrics_record_send_total[1m])`
  - Consumer: `rate(kafka_consumer_fetch_manager_records_consumed_total[1m])`
- **単位:** ops
- **確認ポイント:** 
  - Producer ≒ Consumer → バランスが取れている
  - Producer > Consumer → Lagが増加中

#### ⏱️ Kafka リクエストレイテンシ
- **メトリクス:**
  - Producer: `kafka_producer_metrics_request_latency_avg`
  - Consumer: `kafka_consumer_fetch_manager_fetch_latency_avg`
- **単位:** ミリ秒
- **閾値:**
  - 🟢 緑: < 50ms （優秀）
  - 🟡 黄: 50-100ms （正常）
  - 🟠 橙: 100-200ms （遅い）
  - 🔴 赤: ≥ 200ms （深刻）
- **対策:** Kafkaブローカー確認、ネットワーク調査

---

### 7. 📊 メッセージフロー全体

#### 🔄 エンドツーエンド メッセージフロー
- **目的:** HTTP → Camel → Kafka → 処理の全体フローを可視化
- **表示内容:**
  1. HTTP POST /api/orders
  2. Camel Producer → Kafka
  3. Kafka → Camel Consumer
  4. Processing Success
  5. Processing Failed
- **確認ポイント:** すべてのステップが同期して動作しているか

---

## 🎨 ダッシュボードの使い方

### 日常監視（推奨設定）

1. **自動更新:** 5秒（デフォルト）
2. **時間範囲:** Last 15 minutes または Last 1 hour
3. **重点確認パネル:**
   - ⭐ リクエストキューサイズ（Undertow）
   - ❌ エラー率（Camel）
   - 📊 Consumer Lag（Kafka）
   - 🧠 ヒープメモリ使用率（JVM）

### パフォーマンステスト時

1. **自動更新:** 5秒
2. **時間範囲:** Last 5 minutes
3. **重点確認パネル:**
   - 📨 メッセージ処理レート
   - ⏰ HTTPレスポンスタイム
   - 🧵 ワーカースレッド状態
   - 📊 スレッド使用率

### トラブルシューティング時

1. **自動更新:** 一時停止
2. **時間範囲:** 問題発生時刻を含む範囲に設定
3. **確認手順:**
   1. エラー率 → エラーの有無確認
   2. リクエストキューサイズ → ボトルネック確認
   3. Consumer Lag → Kafka遅延確認
   4. GC → メモリ問題確認

---

## 🚨 アラート推奨設定

### クリティカルアラート（即座に対応が必要）

| メトリクス | 条件 | 期間 | アクション |
|-----------|------|------|-----------|
| ヒープメモリ使用率 | ≥ 90% | 5分 | メモリリーク調査、再起動検討 |
| エラー率 | ≥ 10% | 5分 | ログ確認、ロールバック検討 |
| リクエストキューサイズ | ≥ 100 | 5分 | スレッド増加、スケールアウト |
| Consumer Lag | ≥ 1000 | 10分 | Consumer並列度増加 |

### 警告アラート（注意が必要）

| メトリクス | 条件 | 期間 | アクション |
|-----------|------|------|-----------|
| CPU使用率 | ≥ 70% | 10分 | スケーリング検討 |
| スレッド使用率 | ≥ 80% | 10分 | スレッド数調整検討 |
| GCオーバーヘッド | ≥ 10% | 10分 | GCチューニング検討 |

---

## 📊 パフォーマンス目標値

### レスポンスタイム

| エンドポイント | 平均 | 95パーセンタイル | 99パーセンタイル |
|---------------|------|----------------|----------------|
| /api/orders (POST) | < 100ms | < 200ms | < 500ms |
| /actuator/health | < 10ms | < 20ms | < 50ms |

### スループット

| 項目 | 目標値 |
|------|--------|
| HTTPリクエスト | > 100 req/sec |
| Kafkaメッセージ | > 1000 msg/sec |
| エラー率 | < 1% |

### リソース使用率

| リソース | 通常時 | ピーク時上限 |
|---------|--------|------------|
| CPU | 20-40% | < 70% |
| ヒープメモリ | 40-60% | < 80% |
| スレッド使用率 | 30-50% | < 80% |

---

## 🔗 関連ドキュメント

- [DASHBOARD_QUICKSTART.md](DASHBOARD_QUICKSTART.md) - クイックスタートガイド
- [GRAFANA_SETUP.md](../../GRAFANA_SETUP.md) - Grafana初期設定
- [METRICS_GUIDE.md](../../METRICS_GUIDE.md) - メトリクス詳細ガイド
- [ALERTING_GUIDE.md](../../ALERTING_GUIDE.md) - アラート設定ガイド

---

## 💡 Tips

### グラフの読み方

**時系列グラフ:**
- 横軸: 時間
- 縦軸: メトリクス値
- 凡例: クリックで表示/非表示切り替え

**ゲージ:**
- 色で状態を判断
- しきい値で自動的に色が変わる

**Stat:**
- 最新の値を大きく表示
- 背景色で状態を判断

### データの絞り込み

変数を使用して特定のアプリケーションやインスタンスに絞り込むことができます（将来的に実装予定）。

### エクスポート

ダッシュボードをJSON形式でエクスポートして、他の環境で使用可能。

---

このダッシュボードを使用して、アプリケーションの健全性を継続的に監視し、問題を早期に発見してください！🚀


